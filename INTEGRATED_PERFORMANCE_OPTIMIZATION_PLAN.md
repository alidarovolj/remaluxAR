# üéØ –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–ª–∞–Ω –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ AR —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ remaluxAR

## üìã **–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ —Ä–µ–∑—é–º–µ**

–û–±—ä–µ–¥–∏–Ω—è—è –≥–ª—É–±–æ–∫–æ–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã—Ö –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ Unity AR —Å –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–º–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ–º **–∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –ø–ª–∞–Ω —Ä–∞–±–æ—Ç** –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ remaluxAR –ø—Ä–æ–µ–∫—Ç–∞.

### **–ü—Ä–æ–±–ª–µ–º–∞—Ç–∏–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞:**
- üêå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ª–∞–≥–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ AR —Å—Ü–µ–Ω—ã
- ü§ñ –ú–æ–¥–µ–ª—å TopFormer –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è 800ms+ (—Ü–µ–ª—å: <150ms)
- üì± –ù–∏–∑–∫–∏–π FPS (~8-10, —Ü–µ–ª—å: 25+)
- üî• –ü–µ—Ä–µ–≥—Ä–µ–≤ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∏ throttling
- üíæ –ù–µ–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏

### **–ö–ª—é—á–µ–≤—ã–µ —Ü–µ–ª–µ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏:**
| –ü–∞—Ä–∞–º–µ—Ç—Ä | –¢–µ–∫—É—â–µ–µ | –§–∞–∑–∞ 1 | –§–∞–∑–∞ 2 | –§–∞–∑–∞ 3 |
|----------|---------|--------|--------|--------|
| **FPS** | ~8-10 | 15+ | 20+ | 25+ |
| **–í—Ä–µ–º—è –º–æ–¥–µ–ª–∏** | 800ms+ | <400ms | <200ms | <150ms |
| **Memory Peak** | ? | <1.2GB | <1GB | <800MB |
| **Battery Life** | ? | +20% | +35% | +50% |
| **Thermal State** | –ü–µ—Ä–µ–≥—Ä–µ–≤ | –°—Ç–∞–±–∏–ª—å–Ω–æ | –û–ø—Ç–∏–º–∞–ª—å–Ω–æ | –•–æ–ª–æ–¥–Ω—ã–π |

---

## üöÄ **–§–ê–ó–ê 1: –ë—ã—Å—Ç—Ä—ã–µ –ø–æ–±–µ–¥—ã (1-2 –Ω–µ–¥–µ–ª–∏)**

### **1.1 –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∏ –±–∞–∑–æ–≤—ã–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è**
```bash
–î–µ–Ω—å 1-2: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
```

**–î–µ–π—Å—Ç–≤–∏—è:**
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å `PerformanceBenchmark` –∫–æ–º–ø–æ–Ω–µ–Ω—Ç 
- ‚úÖ –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ–ª–Ω—ã–π –±–µ–Ω—á–º–∞—Ä–∫ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è baseline
- ‚úÖ –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å Unity Profiler —Å Deep Profiling
- ‚úÖ –°–æ–∑–¥–∞—Ç—å –æ—Ç—á–µ—Ç –æ —Ç–µ–∫—É—â–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏

**–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã:**
- Unity Profiler (CPU, Memory, GPU)
- –ö–∞—Å—Ç–æ–º–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ `PerformanceBenchmark`
- Platform-specific –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤—â–∏–∫–∏ (Xcode Instruments/Android Studio)

**–ì–æ—Ç–æ–≤—ã–π –∫–æ–¥ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏:**
```csharp
// –î–æ–±–∞–≤–∏—Ç—å –≤ —Å—Ü–µ–Ω—É –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
[System.Serializable]
public class BaselineMeasurement {
    public float averageFPS;
    public float modelTime;
    public float memoryUsage;
    public float thermalState;
    
    public void RecordBaseline() {
        using (var profilerMarker = new ProfilerMarker("Baseline_Measurement").Auto()) {
            averageFPS = 1.0f / Time.deltaTime;
            memoryUsage = Profiler.GetTotalAllocatedMemory(Profiler.Area.Managed) / (1024f * 1024f);
            thermalState = SystemInfo.thermalState;
        }
    }
}
```

### **1.2 ML-–∫–æ–Ω–≤–µ–π–µ—Ä: –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è**
```bash
–î–µ–Ω—å 2-4: –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ GPU –∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: Barracuda –±—ç–∫–µ–Ω–¥ (–°–∞–º–æ–µ –≤–∞–∂–Ω–æ–µ!)**
```csharp
// ‚ùå –¢–µ–∫—É—â–µ–µ (–º–µ–¥–ª–µ–Ω–Ω–æ):
worker = model.CreateWorker(WorkerFactory.Type.CSharp);

// ‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ (–±—ã—Å—Ç—Ä–æ):
worker = model.CreateWorker(WorkerFactory.Type.ComputeShader);
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ**
```csharp
// ‚ùå –ë–ª–æ–∫–∏—Ä—É—é—â–∏–π –≥–ª–∞–≤–Ω—ã–π –ø–æ—Ç–æ–∫:
worker.Execute(inputTensor);
var output = worker.PeekOutput();

// ‚úÖ –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥:
private IEnumerator AsyncInferenceLoop() {
    while (isProcessing) {
        using (var profilerMarker = new ProfilerMarker("ML_Async_Inference").Auto()) {
            var request = worker.ExecuteAsync(inputTensor);
            yield return request;
            
            if (request.hasError) {
                Debug.LogError($"ML Inference failed: {request.error}");
                continue;
            }
            
            var output = request.PeekOutput();
            ProcessResults(output);
        }
        
        yield return new WaitForSeconds(1f / targetProcessingFPS);
    }
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:** 200-500% —É—Å–∫–æ—Ä–µ–Ω–∏–µ –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–∞

### **1.3 –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ GC-–∞–ª–ª–æ–∫–∞—Ü–∏–π**
```bash
–î–µ–Ω—å 4-6: –ü–æ–∏—Å–∫ –∏ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ "–º—É—Å–æ—Ä–∞"
```

**–¶–µ–ª–µ–≤—ã–µ –æ–±–ª–∞—Å—Ç–∏ –ø–æ–∏—Å–∫–∞:**
- –ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è —Å—Ç—Ä–æ–∫ –≤ `Update()`
- LINQ –∑–∞–ø—Ä–æ—Å—ã –≤ —Ü–∏–∫–ª–∞—Ö
- –í—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
- `GetComponent()` –≤ hot paths
- –ë–æ–∫—Å–∏–Ω–≥ value types

**–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è:**
```csharp
// ‚ùå –ü–ª–æ—Ö–æ: —Å–æ–∑–¥–∞–µ—Ç –º—É—Å–æ—Ä –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä
void Update() {
    string info = "FPS: " + fps + " Model: " + modelTime + "ms";
    debugText.text = info;
    
    // LINQ –≤ Update - –æ—á–µ–Ω—å –ø–ª–æ—Ö–æ!
    var activeObjects = FindObjectsOfType<MonoBehaviour>()
        .Where(obj => obj.gameObject.activeInHierarchy)
        .ToList();
}

// ‚úÖ –•–æ—Ä–æ—à–æ: zero allocation
private StringBuilder sb = new StringBuilder(100);
private List<MonoBehaviour> reusableList = new List<MonoBehaviour>(50);

void Update() {
    // StringBuilder –≤–º–µ—Å—Ç–æ –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏–∏
    sb.Clear();
    sb.Append("FPS: ").Append(fps.ToString("F1"))
      .Append(" Model: ").Append(modelTime.ToString("F0")).Append("ms");
    debugText.text = sb.ToString();
    
    // –ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤–º–µ—Å—Ç–æ LINQ
    GetActiveObjects(reusableList);
}

void GetActiveObjects(List<MonoBehaviour> output) {
    output.Clear();
    foreach (var obj in cachedObjects) {
        if (obj.gameObject.activeInHierarchy) {
            output.Add(obj);
        }
    }
}
```

### **1.4 –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥**
```bash
–î–µ–Ω—å 6-7: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º
```

**–ü–∞—Ç—Ç–µ—Ä–Ω –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤:**
```csharp
public class OptimizedSegmentationManager : MonoBehaviour {
    [Header("Cached References")]
    private Camera arCamera;
    private Transform cameraTransform;
    private CanvasGroup uiGroup;
    private RenderTexture processingTexture;
    private Material postProcessMaterial;
    
    // –ö—ç—à–∏—Ä—É–µ–º –≤—Å—ë –≤ Awake/Start
    void Awake() {
        arCamera = Camera.main;
        cameraTransform = arCamera.transform;
        uiGroup = GetComponent<CanvasGroup>();
        
        // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
        processingTexture = new RenderTexture(256, 256, 0, RenderTextureFormat.ARGBFloat);
        postProcessMaterial = Resources.Load<Material>("PostProcessMaterial");
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Å—ã–ª–∫–∏ –≤ Update
    void Update() {
        Vector3 cameraPos = cameraTransform.position; // ‚úÖ –ë—ã—Å—Ç—Ä–æ
        // –í–º–µ—Å—Ç–æ: Camera.main.transform.position; // ‚ùå –ú–µ–¥–ª–µ–Ω–Ω–æ
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥—Å–æ–∑–¥–∞–Ω–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã
        Graphics.Blit(sourceTexture, processingTexture, postProcessMaterial);
    }
    
    void OnDestroy() {
        // –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
        if (processingTexture != null) {
            processingTexture.Release();
        }
    }
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –§–∞–∑—ã 1:** FPS 15+, –≤—Ä–µ–º—è –º–æ–¥–µ–ª–∏ <400ms

---

## ‚ö° **–§–ê–ó–ê 2: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ (2-4 –Ω–µ–¥–µ–ª–∏)**

### **2.1 ML-–º–æ–¥–µ–ª—å: –∫–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏—è –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è**
```bash
–ù–µ–¥–µ–ª—è 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –º–æ–¥–µ–ª–∏
```

**2.1.1 FP16 –∫–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏—è (–ø–µ—Ä–≤–æ–æ—á–µ—Ä–µ–¥–Ω–æ)**
```python
# –°–∫—Ä–∏–ø—Ç –¥–ª—è –∫–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏–∏ TopFormer –º–æ–¥–µ–ª–∏
import onnx
from onnxruntime.quantization import quantize_dynamic, QuantType

def quantize_topformer_fp16(input_model_path, output_model_path):
    """–ö–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏—è TopFormer –≤ FP16"""
    model = onnx.load(input_model_path)
    
    # FP16 –∫–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏—è
    model_fp16 = onnx.helper.convert_float_to_float16(model)
    onnx.save(model_fp16, output_model_path)
    
    print(f"Model quantized to FP16: {output_model_path}")
    return output_model_path

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
quantize_topformer_fp16("topformer_fp32.onnx", "topformer_fp16.onnx")
```

**–û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã FP16:**
- ‚úÖ –£—Å–∫–æ—Ä–µ–Ω–∏–µ: 20-50%
- ‚úÖ –†–∞–∑–º–µ—Ä –º–æ–¥–µ–ª–∏: -50%
- ‚úÖ –ü–æ—Ç–µ—Ä—è —Ç–æ—á–Ω–æ—Å—Ç–∏: –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è

**2.1.2 INT8 –∫–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏—è (–µ—Å–ª–∏ FP16 –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ)**
```python
def quantize_topformer_int8(input_model_path, calibration_dataset):
    """INT8 –∫–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏—è —Å –∫–∞–ª–∏–±—Ä–æ–≤–∫–æ–π"""
    quantized_model = quantize_dynamic(
        input_model_path,
        "topformer_int8.onnx",
        weight_type=QuantType.QInt8
    )
    
    # –¢—Ä–µ–±—É–µ—Ç –∫–∞–ª–∏–±—Ä–æ–≤–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    calibrate_model(quantized_model, calibration_dataset)
    return quantized_model
```

**2.1.3 –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä**
```csharp
public class ModelComparison : MonoBehaviour {
    [System.Serializable]
    public class ModelConfig {
        public string name;
        public NNModel model;
        public Vector2Int inputSize;
        public float expectedAccuracy;
    }
    
    public ModelConfig[] modelsToTest = new ModelConfig[] {
        new ModelConfig { name = "TopFormer-FP16", inputSize = new Vector2Int(256, 256) },
        new ModelConfig { name = "DeepLabV3-MobileNet", inputSize = new Vector2Int(224, 224) },
        new ModelConfig { name = "FastSCNN", inputSize = new Vector2Int(128, 128) }
    };
    
    public IEnumerator CompareModels() {
        foreach (var config in modelsToTest) {
            yield return TestModel(config);
        }
    }
}
```

### **2.2 GPU-—É—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –ø—Ä–µ/–ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞**
```bash
–ù–µ–¥–µ–ª—è 2: Compute Shaders
```

**2.2.1 Compute Shader –¥–ª—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∏:**
```hlsl
// PreprocessingShader.compute
#pragma kernel CSPreprocess

Texture2D<float4> InputTexture;
RWStructuredBuffer<float> OutputBuffer;

int inputWidth;
int inputHeight;
int outputWidth;
int outputHeight;
float3 mean;
float3 std;

[numthreads(8,8,1)]
void CSPreprocess (uint3 id : SV_DispatchThreadID) {
    if (id.x >= outputWidth || id.y >= outputHeight) return;
    
    // Bilinear resize –Ω–∞ GPU
    float2 uv = float2(id.x / (float)outputWidth, id.y / (float)outputHeight);
    float4 pixel = InputTexture.SampleLevel(sampler_InputTexture, uv, 0);
    
    // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
    float3 normalized = (pixel.rgb - mean) / std;
    
    // –ó–∞–ø–∏—Å—å –≤ –±—É—Ñ–µ—Ä –≤ —Ñ–æ—Ä–º–∞—Ç–µ CHW
    int baseIndex = id.x + id.y * outputWidth;
    OutputBuffer[baseIndex] = normalized.r;                           // R channel
    OutputBuffer[baseIndex + outputWidth * outputHeight] = normalized.g;     // G channel  
    OutputBuffer[baseIndex + outputWidth * outputHeight * 2] = normalized.b; // B channel
}
```

**2.2.2 C# –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è GPU –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∏:**
```csharp
public class GPUPreprocessor : MonoBehaviour {
    [Header("GPU Preprocessing")]
    public ComputeShader preprocessShader;
    
    private ComputeBuffer outputBuffer;
    private int kernelIndex;
    private readonly Vector3 meanRGB = new Vector3(0.485f, 0.456f, 0.406f);
    private readonly Vector3 stdRGB = new Vector3(0.229f, 0.224f, 0.225f);
    
    void Start() {
        kernelIndex = preprocessShader.FindKernel("CSPreprocess");
        
        // –°–æ–∑–¥–∞–µ–º –±—É—Ñ–µ—Ä –¥–ª—è –≤—ã—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        int bufferSize = 256 * 256 * 3; // RGB channels
        outputBuffer = new ComputeBuffer(bufferSize, sizeof(float));
        
        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        preprocessShader.SetVector("mean", meanRGB);
        preprocessShader.SetVector("std", stdRGB);
        preprocessShader.SetBuffer(kernelIndex, "OutputBuffer", outputBuffer);
    }
    
    public Tensor PreprocessOnGPU(Texture2D inputTexture, int targetWidth = 256, int targetHeight = 256) {
        using (var profilerMarker = new ProfilerMarker("GPU_Preprocessing").Auto()) {
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            preprocessShader.SetTexture(kernelIndex, "InputTexture", inputTexture);
            preprocessShader.SetInt("inputWidth", inputTexture.width);
            preprocessShader.SetInt("inputHeight", inputTexture.height);
            preprocessShader.SetInt("outputWidth", targetWidth);
            preprocessShader.SetInt("outputHeight", targetHeight);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º compute shader
            int threadGroupsX = Mathf.CeilToInt(targetWidth / 8f);
            int threadGroupsY = Mathf.CeilToInt(targetHeight / 8f);
            preprocessShader.Dispatch(kernelIndex, threadGroupsX, threadGroupsY, 1);
            
            // –°–æ–∑–¥–∞–µ–º —Ç–µ–Ω–∑–æ—Ä –∏–∑ GPU –±—É—Ñ–µ—Ä–∞
            var tensorShape = new TensorShape(1, 3, targetHeight, targetWidth);
            return new Tensor(tensorShape, outputBuffer);
        }
    }
    
    void OnDestroy() {
        outputBuffer?.Dispose();
    }
}
```

**–û–∂–∏–¥–∞–µ–º–æ–µ —É—Å–∫–æ—Ä–µ–Ω–∏–µ:** 5-20x –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å CPU –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–æ–π

### **2.3 –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–∞–º–∏**
```bash
–ù–µ–¥–µ–ª—è 3: Object Pooling –∏ Memory Management
```

**2.3.1 –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—É–ª–∏–Ω–≥–∞:**
```csharp
public class UniversalObjectPool<T> : MonoBehaviour where T : MonoBehaviour {
    [Header("Pool Configuration")]
    public T prefab;
    public int preAllocateCount = 10;
    public int maxPoolSize = 50;
    public bool autoExpand = true;
    
    private Queue<T> available = new Queue<T>();
    private HashSet<T> inUse = new HashSet<T>();
    
    void Start() {
        // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
        for (int i = 0; i < preAllocateCount; i++) {
            var obj = CreateNewObject();
            ReturnToPool(obj);
        }
    }
    
    public T Get() {
        T obj;
        
        if (available.Count > 0) {
            obj = available.Dequeue();
        } else if (autoExpand && inUse.Count < maxPoolSize) {
            obj = CreateNewObject();
        } else {
            Debug.LogWarning($"Pool exhausted for {typeof(T).Name}");
            return null;
        }
        
        obj.gameObject.SetActive(true);
        inUse.Add(obj);
        return obj;
    }
    
    public void Return(T obj) {
        if (obj == null || !inUse.Contains(obj)) return;
        
        obj.gameObject.SetActive(false);
        inUse.Remove(obj);
        available.Enqueue(obj);
    }
    
    private T CreateNewObject() {
        var obj = Instantiate(prefab, transform);
        obj.gameObject.SetActive(false);
        return obj;
    }
}

// –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—É–ª—ã –¥–ª—è AR –æ–±—ä–µ–∫—Ç–æ–≤
[System.Serializable]
public class ARObjectPools {
    public UniversalObjectPool<ARSegmentationMarker> segmentationMarkers;
    public UniversalObjectPool<ARPlaneVisualization> planeVisuals;
    public UniversalObjectPool<ARFeaturePlot> featurePoints;
}
```

**2.3.2 –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ Addressable Asset System:**
```csharp
public class OptimizedAssetManager : MonoBehaviour {
    [Header("Addressable Assets")]
    public AssetReference[] mlModels;
    public AssetReference[] uiPrefabs;
    
    private Dictionary<string, AsyncOperationHandle> loadedAssets = new Dictionary<string, AsyncOperationHandle>();
    
    public async Task<T> LoadAssetAsync<T>(AssetReference assetRef) where T : UnityEngine.Object {
        if (loadedAssets.ContainsKey(assetRef.AssetGUID)) {
            var handle = loadedAssets[assetRef.AssetGUID];
            return handle.Result as T;
        }
        
        var loadHandle = Addressables.LoadAssetAsync<T>(assetRef);
        loadedAssets[assetRef.AssetGUID] = loadHandle;
        
        return await loadHandle.Task;
    }
    
    public void ReleaseAsset(AssetReference assetRef) {
        if (loadedAssets.TryGetValue(assetRef.AssetGUID, out var handle)) {
            Addressables.Release(handle);
            loadedAssets.Remove(assetRef.AssetGUID);
        }
    }
}
```

### **2.4 –ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**
```bash
–ù–µ–¥–µ–ª—è 4: C# Job System –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
```

**2.4.1 –ü–∞—Ä–∞–ª–ª–µ–ª–∏–∑–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö:**
```csharp
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct TensorProcessingJob : IJobParallelFor {
    [ReadOnly] public NativeArray<float> inputTensor;
    public NativeArray<float> outputTensor;
    [ReadOnly] public float threshold;
    [ReadOnly] public float multiplier;
    
    public void Execute(int index) {
        float value = inputTensor[index];
        value = math.clamp(value * multiplier, 0f, 1f);
        outputTensor[index] = value > threshold ? 1f : 0f;
    }
}

public class ParallelTensorProcessor : MonoBehaviour {
    private NativeArray<float> inputData;
    private NativeArray<float> outputData;
    
    public JobHandle ProcessTensorParallel(float[] input, float threshold = 0.5f) {
        using (var profilerMarker = new ProfilerMarker("Parallel_Tensor_Processing").Auto()) {
            // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –Ω–∞—Ç–∏–≤–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤
            if (!inputData.IsCreated || inputData.Length != input.Length) {
                if (inputData.IsCreated) inputData.Dispose();
                if (outputData.IsCreated) outputData.Dispose();
                
                inputData = new NativeArray<float>(input.Length, Allocator.Persistent);
                outputData = new NativeArray<float>(input.Length, Allocator.Persistent);
            }
            
            inputData.CopyFrom(input);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏
            var job = new TensorProcessingJob {
                inputTensor = inputData,
                outputTensor = outputData,
                threshold = threshold,
                multiplier = 2.0f
            };
            
            return job.Schedule(input.Length, 64); // 64 —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–∞ batch
        }
    }
    
    void OnDestroy() {
        if (inputData.IsCreated) inputData.Dispose();
        if (outputData.IsCreated) outputData.Dispose();
    }
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –§–∞–∑—ã 2:** FPS 20+, –≤—Ä–µ–º—è –º–æ–¥–µ–ª–∏ <200ms

---

## üî¨ **–§–ê–ó–ê 3: –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è (1-2 –º–µ—Å—è—Ü–∞)**

### **3.1 Platform-specific —É—Å–∫–æ—Ä–µ–Ω–∏–µ**
```bash
–ú–µ—Å—è—Ü 1: –ù–∞—Ç–∏–≤–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
```

**3.1.1 Android: NNAPI –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è**
```csharp
#if UNITY_ANDROID && !UNITY_EDITOR
public class AndroidNNAPIAccelerator : MonoBehaviour {
    private AndroidJavaObject nnapiWrapper;
    private AndroidJavaObject context;
    
    void Start() {
        InitializeNNAPI();
    }
    
    void InitializeNNAPI() {
        try {
            using (var unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
            using (var activity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity")) {
                context = activity.Call<AndroidJavaObject>("getApplicationContext");
                nnapiWrapper = new AndroidJavaObject("com.remaluxar.NNAPIWrapper");
                
                bool initialized = nnapiWrapper.Call<bool>("initializeNNAPI", context);
                Debug.Log($"NNAPI initialized: {initialized}");
            }
        } catch (System.Exception e) {
            Debug.LogError($"NNAPI initialization failed: {e.Message}");
        }
    }
    
    public float[] RunInferenceNNAPI(float[] input) {
        if (nnapiWrapper == null) return null;
        
        using (var profilerMarker = new ProfilerMarker("NNAPI_Inference").Auto()) {
            var inputJavaArray = AndroidJNIHelper.ConvertToJNIArray(input);
            var outputJavaArray = nnapiWrapper.Call<float[]>("runInference", inputJavaArray);
            return outputJavaArray;
        }
    }
}
#endif
```

**3.1.2 iOS: Core ML –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è**
```csharp
#if UNITY_IOS && !UNITY_EDITOR
using System.Runtime.InteropServices;

public class iOSCoreMLAccelerator : MonoBehaviour {
    [DllImport("__Internal")]
    private static extern bool InitializeCoreML(string modelPath);
    
    [DllImport("__Internal")]
    private static extern int RunCoreMLInference(float[] input, int length, float[] output);
    
    [DllImport("__Internal")]
    private static extern float GetInferenceTime();
    
    private bool coreMLInitialized = false;
    
    void Start() {
        string modelPath = Path.Combine(Application.streamingAssetsPath, "topformer_coreml.mlmodel");
        coreMLInitialized = InitializeCoreML(modelPath);
        Debug.Log($"Core ML initialized: {coreMLInitialized}");
    }
    
    public float[] RunInferenceCoreML(float[] input) {
        if (!coreMLInitialized) return null;
        
        using (var profilerMarker = new ProfilerMarker("CoreML_Inference").Auto()) {
            float[] output = new float[256 * 256]; // Adjust size
            int result = RunCoreMLInference(input, input.Length, output);
            
            if (result == 0) {
                float inferenceTime = GetInferenceTime();
                Debug.Log($"Core ML inference time: {inferenceTime}ms");
                return output;
            }
            
            return null;
        }
    }
}
#endif
```

### **3.2 –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è –∞–¥–∞–ø—Ç–∞—Ü–∏—è**
```bash
–ú–µ—Å—è—Ü 2: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–æ–º
```

**3.2.1 Advanced Thermal Management System:**
```csharp
public class IntelligentThermalManager : MonoBehaviour {
    [Header("Thermal Configuration")]
    public float criticalTemperature = 0.8f;
    public float optimalTemperature = 0.4f;
    public float coolingRate = 0.1f;
    
    [Header("Quality Levels")]
    public QualityLevel[] qualityLevels;
    
    private int currentQualityLevel = 2; // Start at medium
    private float thermalHistory = 0f;
    private Coroutine thermalMonitoring;
    
    [System.Serializable]
    public class QualityLevel {
        public string name;
        public Vector2Int modelInputSize;
        public int targetFPS;
        public float processingInterval;
        public bool useGPUPreprocessing;
        public ComputeShaderQuality shaderQuality;
    }
    
    void Start() {
        thermalMonitoring = StartCoroutine(MonitorThermalState());
    }
    
    private IEnumerator MonitorThermalState() {
        while (true) {
            float currentThermal = SystemInfo.thermalState;
            thermalHistory = Mathf.Lerp(thermalHistory, currentThermal, Time.deltaTime * coolingRate);
            
            // –ü—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–ø–ª–æ–≤–æ–π –∏—Å—Ç–æ—Ä–∏–∏
            if (thermalHistory > criticalTemperature && currentQualityLevel > 0) {
                ReduceQuality();
            } else if (thermalHistory < optimalTemperature && currentQualityLevel < qualityLevels.Length - 1) {
                IncreaseQuality();
            }
            
            yield return new WaitForSeconds(2f); // Check every 2 seconds
        }
    }
    
    void ReduceQuality() {
        currentQualityLevel = Mathf.Max(0, currentQualityLevel - 1);
        ApplyQualityLevel(qualityLevels[currentQualityLevel]);
        Debug.Log($"üî• Thermal protection: Reduced to {qualityLevels[currentQualityLevel].name}");
    }
    
    void IncreaseQuality() {
        currentQualityLevel = Mathf.Min(qualityLevels.Length - 1, currentQualityLevel + 1);
        ApplyQualityLevel(qualityLevels[currentQualityLevel]);
        Debug.Log($"‚ùÑÔ∏è Thermal recovery: Increased to {qualityLevels[currentQualityLevel].name}");
    }
    
    void ApplyQualityLevel(QualityLevel level) {
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ –∫ —Å–∏—Å—Ç–µ–º–µ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏
        var segmentationManager = FindFirstObjectByType<SegmentationManager>();
        if (segmentationManager != null) {
            segmentationManager.UpdateQualitySettings(level);
        }
    }
}
```

**3.2.2 Adaptive Frame Rate Management:**
```csharp
public class AdaptiveFrameRateManager : MonoBehaviour {
    [Header("Frame Rate Targets")]
    public int[] targetFrameRates = { 15, 20, 30, 60 };
    public float frameTimeThreshold = 33.3f; // 30 FPS threshold
    
    private Queue<float> frameTimeHistory = new Queue<float>();
    private int maxHistorySize = 30;
    private int currentTargetIndex = 1; // Start at 20 FPS
    
    void Update() {
        float currentFrameTime = Time.deltaTime * 1000f; // Convert to ms
        frameTimeHistory.Enqueue(currentFrameTime);
        
        if (frameTimeHistory.Count > maxHistorySize) {
            frameTimeHistory.Dequeue();
        }
        
        // –ê–Ω–∞–ª–∏–∑ –∫–∞–∂–¥—ã–µ –ø–æ–ª—Å–µ–∫—É–Ω–¥—ã
        if (Time.frameCount % 30 == 0) {
            AnalyzePerformance();
        }
    }
    
    void AnalyzePerformance() {
        float averageFrameTime = frameTimeHistory.Average();
        float targetFrameTime = 1000f / targetFrameRates[currentTargetIndex];
        
        if (averageFrameTime > targetFrameTime * 1.2f) {
            // –°–Ω–∏–∂–∞–µ–º target FPS
            currentTargetIndex = Mathf.Max(0, currentTargetIndex - 1);
            ApplyFrameRate(targetFrameRates[currentTargetIndex]);
        } else if (averageFrameTime < targetFrameTime * 0.8f) {
            // –ü–æ–≤—ã—à–∞–µ–º target FPS
            currentTargetIndex = Mathf.Min(targetFrameRates.Length - 1, currentTargetIndex + 1);
            ApplyFrameRate(targetFrameRates[currentTargetIndex]);
        }
    }
    
    void ApplyFrameRate(int targetFPS) {
        Application.targetFrameRate = targetFPS;
        Debug.Log($"üì± Adaptive FPS: Target set to {targetFPS}");
    }
}
```

### **3.3 –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ ML —Ç–µ—Ö–Ω–∏–∫–∏**
```bash
–ú–µ—Å—è—Ü 2: –≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã
```

**3.3.1 Knowledge Distillation –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ª–µ–≥–∫–æ–π –º–æ–¥–µ–ª–∏:**
```python
# Python —Å–∫—Ä–∏–ø—Ç –¥–ª—è –æ–±—É—á–µ–Ω–∏—è distilled –º–æ–¥–µ–ª–∏
import torch
import torch.nn as nn
import torch.nn.functional as F

class DistillationLoss(nn.Module):
    def __init__(self, alpha=0.5, temperature=4.0):
        super().__init__()
        self.alpha = alpha
        self.temperature = temperature
        self.kl_loss = nn.KLDivLoss(reduction='batchmean')
        self.ce_loss = nn.CrossEntropyLoss()
    
    def forward(self, student_logits, teacher_logits, labels):
        # Soft targets –æ—Ç teacher –º–æ–¥–µ–ª–∏
        soft_teacher = F.softmax(teacher_logits / self.temperature, dim=1)
        soft_student = F.log_softmax(student_logits / self.temperature, dim=1)
        
        # Distillation loss
        distill_loss = self.kl_loss(soft_student, soft_teacher) * (self.temperature ** 2)
        
        # Classification loss
        student_loss = self.ce_loss(student_logits, labels)
        
        return self.alpha * distill_loss + (1 - self.alpha) * student_loss

def train_distilled_model(teacher_model, student_model, dataloader):
    """–û–±—É—á–µ–Ω–∏–µ –æ–±–ª–µ–≥—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –Ω–∞ –∑–Ω–∞–Ω–∏—è—Ö TopFormer"""
    criterion = DistillationLoss(alpha=0.7, temperature=4.0)
    optimizer = torch.optim.Adam(student_model.parameters(), lr=1e-3)
    
    for epoch in range(50):
        for batch_idx, (data, labels) in enumerate(dataloader):
            with torch.no_grad():
                teacher_logits = teacher_model(data)
            
            student_logits = student_model(data)
            loss = criterion(student_logits, teacher_logits, labels)
            
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
    
    return student_model
```

**3.3.2 Temporal Smoothing –∏ Motion Prediction:**
```csharp
public class TemporalSegmentationSmoother : MonoBehaviour {
    [Header("Temporal Configuration")]
    public int maxFrameHistory = 5;
    public float motionThreshold = 0.1f;
    public bool enableMotionPrediction = true;
    
    private Queue<Tensor> frameHistory = new Queue<Tensor>();
    private Vector3 lastCameraPosition;
    private Quaternion lastCameraRotation;
    private Vector3 cameraVelocity;
    
    public Tensor SmoothSegmentation(Tensor currentPrediction, Camera arCamera) {
        using (var profilerMarker = new ProfilerMarker("Temporal_Smoothing").Auto()) {
            // –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
            Vector3 currentPos = arCamera.transform.position;
            Quaternion currentRot = arCamera.transform.rotation;
            
            cameraVelocity = (currentPos - lastCameraPosition) / Time.deltaTime;
            float motionMagnitude = cameraVelocity.magnitude;
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –∫–∞–¥—Ä –≤ –∏—Å—Ç–æ—Ä–∏—é
            frameHistory.Enqueue(currentPrediction);
            if (frameHistory.Count > maxFrameHistory) {
                frameHistory.Dequeue();
            }
            
            Tensor smoothedResult;
            
            if (motionMagnitude < motionThreshold && frameHistory.Count > 1) {
                // –ù–∏–∑–∫–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ - –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–ª—å–Ω–æ–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
                smoothedResult = CalculateWeightedAverage(frameHistory, GetStaticWeights());
            } else {
                // –í—ã—Å–æ–∫–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ - –ø—Ä–∏–º–µ–Ω—è–µ–º motion prediction
                smoothedResult = enableMotionPrediction ? 
                    PredictBasedOnMotion(currentPrediction, cameraVelocity) : 
                    currentPrediction;
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            lastCameraPosition = currentPos;
            lastCameraRotation = currentRot;
            
            return smoothedResult;
        }
    }
    
    private Tensor CalculateWeightedAverage(Queue<Tensor> history, float[] weights) {
        var frames = history.ToArray();
        var result = new Tensor(frames[0].shape);
        
        for (int i = 0; i < frames.Length; i++) {
            // Weighted sum –æ–ø–µ—Ä–∞—Ü–∏—è
            AddWeightedTensor(result, frames[i], weights[i]);
        }
        
        return result;
    }
    
    private Tensor PredictBasedOnMotion(Tensor current, Vector3 velocity) {
        // –ü—Ä–æ—Å—Ç–∞—è –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
        float motionFactor = Mathf.Clamp01(velocity.magnitude * 0.1f);
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º motion blur compensation
        return ApplyMotionCompensation(current, velocity, motionFactor);
    }
    
    private float[] GetStaticWeights() {
        // –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —É–±—ã–≤–∞–Ω–∏–µ –≤–µ—Å–æ–≤: –Ω–æ–≤—ã–µ –∫–∞–¥—Ä—ã –≤–∞–∂–Ω–µ–µ
        return new float[] { 0.5f, 0.25f, 0.15f, 0.07f, 0.03f };
    }
}
```

**3.3.3 Multi-Scale Processing:**
```csharp
public class MultiScaleProcessor : MonoBehaviour {
    [Header("Multi-Scale Configuration")]
    public Vector2Int[] processingScales = {
        new Vector2Int(128, 128),   // Fast preview
        new Vector2Int(256, 256),   // Standard quality  
        new Vector2Int(512, 512)    // High quality
    };
    
    public float[] scaleIntervals = { 0.033f, 0.1f, 0.5f }; // 30fps, 10fps, 2fps
    
    private Tensor[] scaleResults;
    private float[] lastProcessTimes;
    
    void Start() {
        scaleResults = new Tensor[processingScales.Length];
        lastProcessTimes = new float[processingScales.Length];
    }
    
    public Tensor ProcessMultiScale(Texture2D input) {
        using (var profilerMarker = new ProfilerMarker("MultiScale_Processing").Auto()) {
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∏–µ –º–∞—Å—à—Ç–∞–±—ã –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å
            for (int i = 0; i < processingScales.Length; i++) {
                if (Time.time - lastProcessTimes[i] >= scaleIntervals[i]) {
                    StartCoroutine(ProcessScale(input, i));
                    lastProcessTimes[i] = Time.time;
                }
            }
            
            // –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞–∑–Ω—ã—Ö –º–∞—Å—à—Ç–∞–±–æ–≤
            return CombineMultiScaleResults();
        }
    }
    
    private IEnumerator ProcessScale(Texture2D input, int scaleIndex) {
        var scale = processingScales[scaleIndex];
        
        // Resize input –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∞
        var resizedInput = ResizeTexture(input, scale.x, scale.y);
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω—Ñ–µ—Ä–µ–Ω—Å
        var result = yield return RunInferenceForScale(resizedInput, scaleIndex);
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        scaleResults[scaleIndex] = result;
    }
    
    private Tensor CombineMultiScaleResults() {
        // –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã: –≤—ã—Å–æ–∫–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –¥–µ—Ç–∞–ª–µ–π, 
        // –Ω–∏–∑–∫–æ–µ –¥–ª—è –æ–±—â–µ–≥–æ –ø–æ–Ω–∏–º–∞–Ω–∏—è —Å—Ü–µ–Ω—ã
        
        if (scaleResults[2] != null) { // High quality available
            return UpscaleAndRefine(scaleResults[2], scaleResults[1], scaleResults[0]);
        } else if (scaleResults[1] != null) { // Standard quality
            return RefineWithFast(scaleResults[1], scaleResults[0]);
        } else { // Fallback to fast
            return scaleResults[0];
        }
    }
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –§–∞–∑—ã 3:** FPS 25+, –≤—Ä–µ–º—è –º–æ–¥–µ–ª–∏ <150ms, —ç–Ω–µ—Ä–≥–æ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å +50%

---

## üìä **–°–∏—Å—Ç–µ–º–∞ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏ CI/CD**

### **–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π Performance CI/CD –ø–∞–π–ø–ª–∞–π–Ω:**
```yaml
# .github/workflows/performance-regression.yml
name: Performance Regression Detection
on: [push, pull_request]

jobs:
  performance-test:
    runs-on: unity-cloud-build
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Unity
        uses: game-ci/unity-builder@v2
        with:
          targetPlatform: Android
          
      - name: Run Performance Benchmark
        run: |
          unity -batchmode -quit \
            -executeMethod PerformanceBenchmark.RunAutomatedCI \
            -logFile benchmark.log
            
      - name: Parse Performance Results
        run: python scripts/parse_performance.py benchmark.log
        
      - name: Compare with Baseline
        run: |
          python scripts/compare_performance.py \
            --current results.json \
            --baseline baseline/performance.json \
            --threshold 10
            
      - name: Upload Performance Report
        uses: actions/upload-artifact@v3
        with:
          name: performance-report
          path: performance-report.html
          
      - name: Comment PR with Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('performance-summary.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });
            
      - name: Fail if Regression
        run: |
          if [ "$PERFORMANCE_REGRESSION" = "true" ]; then
            echo "‚ùå Performance regression detected!"
            echo "Current FPS: $CURRENT_FPS, Baseline: $BASELINE_FPS"
            echo "Current Model Time: $CURRENT_MODEL_TIME ms, Baseline: $BASELINE_MODEL_TIME ms"
            exit 1
          else
            echo "‚úÖ Performance within acceptable range"
          fi
```

### **Real-time Performance Dashboard:**
```csharp
public class PerformanceDashboard : MonoBehaviour {
    [Header("Dashboard Configuration")]
    public bool enableRealTimeLogging = true;
    public float logInterval = 1f;
    public int maxDataPoints = 100;
    
    [Header("UI References")]
    public Text fpsText;
    public Text modelTimeText;
    public Text memoryText;
    public Text thermalText;
    public LineRenderer fpsGraph;
    public LineRenderer modelTimeGraph;
    
    private PerformanceMetrics currentMetrics;
    private Queue<float> fpsHistory = new Queue<float>();
    private Queue<float> modelTimeHistory = new Queue<float>();
    
    [System.Serializable]
    public class PerformanceMetrics {
        public float averageFPS;
        public float minFPS;
        public float maxFPS;
        public float modelInferenceTime;
        public float memoryUsageMB;
        public float thermalState;
        public float batteryLevel;
        public DateTime timestamp;
        
        public string ToJSON() {
            return JsonUtility.ToJson(this);
        }
    }
    
    void Start() {
        if (enableRealTimeLogging) {
            InvokeRepeating(nameof(CollectMetrics), 0f, logInterval);
        }
    }
    
    void CollectMetrics() {
        using (var profilerMarker = new ProfilerMarker("Performance_Dashboard").Auto()) {
            currentMetrics = new PerformanceMetrics {
                averageFPS = 1.0f / Time.deltaTime,
                memoryUsageMB = Profiler.GetTotalAllocatedMemory(Profiler.Area.Managed) / (1024f * 1024f),
                thermalState = SystemInfo.thermalState,
                batteryLevel = SystemInfo.batteryLevel,
                timestamp = DateTime.Now
            };
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            UpdateDashboardUI();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–∞—Ñ–∏–∫–∏
            UpdatePerformanceGraphs();
            
            // –õ–æ–≥–∏—Ä—É–µ–º –≤ —Ñ–∞–π–ª –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
            if (enableRealTimeLogging) {
                LogToFile(currentMetrics);
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            CheckPerformanceAlerts();
        }
    }
    
    void UpdateDashboardUI() {
        fpsText.text = $"FPS: {currentMetrics.averageFPS:F1}";
        modelTimeText.text = $"Model: {currentMetrics.modelInferenceTime:F0}ms";
        memoryText.text = $"RAM: {currentMetrics.memoryUsageMB:F0}MB";
        
        // Color coding –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –æ—Ü–µ–Ω–∫–∏
        fpsText.color = currentMetrics.averageFPS > 20 ? Color.green : 
                       currentMetrics.averageFPS > 15 ? Color.yellow : Color.red;
        
        modelTimeText.color = currentMetrics.modelInferenceTime < 200 ? Color.green :
                             currentMetrics.modelInferenceTime < 400 ? Color.yellow : Color.red;
    }
    
    void UpdatePerformanceGraphs() {
        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Ç–æ—á–∫–∏ –¥–∞–Ω–Ω—ã—Ö
        fpsHistory.Enqueue(currentMetrics.averageFPS);
        modelTimeHistory.Enqueue(currentMetrics.modelInferenceTime);
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
        while (fpsHistory.Count > maxDataPoints) {
            fpsHistory.Dequeue();
            modelTimeHistory.Dequeue();
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º LineRenderer –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–æ–≤
        UpdateLineRenderer(fpsGraph, fpsHistory.ToArray(), 0, 60); // FPS 0-60
        UpdateLineRenderer(modelTimeGraph, modelTimeHistory.ToArray(), 0, 1000); // Time 0-1000ms
    }
    
    void UpdateLineRenderer(LineRenderer lr, float[] data, float minY, float maxY) {
        lr.positionCount = data.Length;
        
        for (int i = 0; i < data.Length; i++) {
            float x = (float)i / (data.Length - 1) * 10f; // 10 units wide
            float y = Mathf.Lerp(0, 5f, (data[i] - minY) / (maxY - minY)); // 5 units tall
            lr.SetPosition(i, new Vector3(x, y, 0));
        }
    }
    
    void CheckPerformanceAlerts() {
        // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∞–ª–µ—Ä—Ç—ã
        if (currentMetrics.averageFPS < 10) {
            Debug.LogWarning("üö® CRITICAL: FPS below 10!");
            TriggerPerformanceAlert("Critical FPS Drop", currentMetrics);
        }
        
        if (currentMetrics.modelInferenceTime > 800) {
            Debug.LogWarning("üö® CRITICAL: Model inference time > 800ms!");
            TriggerPerformanceAlert("Model Processing Too Slow", currentMetrics);
        }
        
        if (currentMetrics.thermalState > 0.8f) {
            Debug.LogWarning("üî• THERMAL: Device overheating!");
            TriggerPerformanceAlert("Thermal Throttling Risk", currentMetrics);
        }
    }
    
    void TriggerPerformanceAlert(string alertType, PerformanceMetrics metrics) {
        // –ú–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –∞–ª–µ—Ä—Ç—ã –≤ –∞–Ω–∞–ª–∏—Ç–∏–∫—É, –ª–æ–≥-—Å–µ—Ä–≤–∏—Å—ã –∏–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º
        Debug.Log($"ALERT: {alertType} - {metrics.ToJSON()}");
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ–Ω—è–µ–º —ç–∫—Å—Ç—Ä–µ–Ω–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        var emergencyOptimizer = FindFirstObjectByType<EmergencyOptimizer>();
        emergencyOptimizer?.ApplyEmergencyOptimizations(alertType);
    }
    
    void LogToFile(PerformanceMetrics metrics) {
        string logEntry = $"{metrics.timestamp:yyyy-MM-dd HH:mm:ss.fff},{metrics.averageFPS:F2},{metrics.modelInferenceTime:F2},{metrics.memoryUsageMB:F2},{metrics.thermalState:F3}\n";
        string filePath = Path.Combine(Application.persistentDataPath, "performance_log.csv");
        
        File.AppendAllText(filePath, logEntry);
    }
}

public class EmergencyOptimizer : MonoBehaviour {
    public void ApplyEmergencyOptimizations(string alertType) {
        switch (alertType) {
            case "Critical FPS Drop":
                // –≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞
                QualitySettings.SetQualityLevel(0); // Lowest
                Application.targetFrameRate = 15;
                break;
                
            case "Model Processing Too Slow":
                // –í—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º –º–æ–¥–µ–ª—å –∏–ª–∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª
                var segManager = FindFirstObjectByType<SegmentationManager>();
                segManager?.SetExtremeOptimizationMode(true);
                break;
                
            case "Thermal Throttling Risk":
                // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ –Ω–∞–≥—Ä—É–∑–∫–∏
                QualitySettings.SetQualityLevel(0);
                Application.targetFrameRate = 10;
                break;
        }
        
        Debug.Log($"üÜò Emergency optimizations applied for: {alertType}");
    }
}
```

---

## üéØ **–î–µ—Ç–∞–ª—å–Ω–∞—è –¥–æ—Ä–æ–∂–Ω–∞—è –∫–∞—Ä—Ç–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è**

### **–°–ø—Ä–∏–Ω—Ç 1 (–Ω–µ–¥–µ–ª—è 1-2): –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è**
```
üìÖ –î–µ–Ω—å 1-2: –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
‚îú‚îÄ‚îÄ ‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ PerformanceBenchmark –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
‚îú‚îÄ‚îÄ ‚úÖ –ó–∞–ø—É—Å–∫ baseline –∏–∑–º–µ—Ä–µ–Ω–∏–π
‚îú‚îÄ‚îÄ ‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Unity Profiler
‚îî‚îÄ‚îÄ ‚úÖ –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ç—á–µ—Ç–∞ –æ —Ç–µ–∫—É—â–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏

üìÖ –î–µ–Ω—å 3-4: GPU –∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å  
‚îú‚îÄ‚îÄ ‚úÖ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ Barracuda –Ω–∞ GPU backend
‚îú‚îÄ‚îÄ ‚úÖ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–∞
‚îú‚îÄ‚îÄ ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∏–µ ProfilerMarker'–æ–≤
‚îî‚îÄ‚îÄ ‚úÖ –ü–µ—Ä–≤—ã–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è —É—Å–∫–æ—Ä–µ–Ω–∏—è

üìÖ –î–µ–Ω—å 5-7: –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ GC –∞–ª–ª–æ–∫–∞—Ü–∏–π
‚îú‚îÄ‚îÄ ‚úÖ –ü–æ–∏—Å–∫ –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ string concatenation
‚îú‚îÄ‚îÄ ‚úÖ –ó–∞–º–µ–Ω–∞ LINQ –Ω–∞ —Ü–∏–∫–ª—ã –≤ hot paths  
‚îú‚îÄ‚îÄ ‚úÖ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ GetComponent –≤—ã–∑–æ–≤–æ–≤
‚îî‚îÄ‚îÄ ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —á–µ—Ä–µ–∑ Memory Profiler

üéØ –¶–µ–ª—å: FPS 15+, –≤—Ä–µ–º—è –º–æ–¥–µ–ª–∏ <400ms
```

### **–°–ø—Ä–∏–Ω—Ç 2 (–Ω–µ–¥–µ–ª—è 3-4): –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è**
```
üìÖ –ù–µ–¥–µ–ª—è 3: ML –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
‚îú‚îÄ‚îÄ ‚úÖ FP16 –∫–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏—è TopFormer –º–æ–¥–µ–ª–∏
‚îú‚îÄ‚îÄ ‚úÖ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä
‚îú‚îÄ‚îÄ ‚úÖ GPU-—É—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ (Compute Shader)
‚îî‚îÄ‚îÄ ‚úÖ –ò–∑–º–µ—Ä–µ–Ω–∏–µ –ø—Ä–∏—Ä–æ—Å—Ç–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

üìÖ –ù–µ–¥–µ–ª—è 4: –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–∞–º–∏
‚îú‚îÄ‚îÄ ‚úÖ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Object Pooling
‚îú‚îÄ‚îÄ ‚úÖ –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ Addressable Asset System
‚îú‚îÄ‚îÄ ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è C# Job System
‚îî‚îÄ‚îÄ ‚úÖ –ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö

üéØ –¶–µ–ª—å: FPS 20+, –≤—Ä–µ–º—è –º–æ–¥–µ–ª–∏ <200ms  
```

### **–°–ø—Ä–∏–Ω—Ç 3 (–Ω–µ–¥–µ–ª—è 5-8): –ü–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è**
```
üìÖ –ù–µ–¥–µ–ª—è 5-6: Native acceleration
‚îú‚îÄ‚îÄ ‚úÖ Android NNAPI –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
‚îú‚îÄ‚îÄ ‚úÖ iOS Core ML –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è  
‚îú‚îÄ‚îÄ ‚úÖ Platform-specific –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
‚îî‚îÄ‚îÄ ‚úÖ –ë–µ–Ω—á–º–∞—Ä–∫–∏–Ω–≥ –Ω–∞—Ç–∏–≤–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π

üìÖ –ù–µ–¥–µ–ª—è 7-8: Intelligent adaptation
‚îú‚îÄ‚îÄ ‚úÖ Thermal Management System
‚îú‚îÄ‚îÄ ‚úÖ Adaptive Frame Rate Management
‚îú‚îÄ‚îÄ ‚úÖ Temporal Smoothing
‚îî‚îÄ‚îÄ ‚úÖ Multi-Scale Processing

üéØ –¶–µ–ª—å: FPS 25+, –≤—Ä–µ–º—è –º–æ–¥–µ–ª–∏ <150ms, +50% —ç–Ω–µ—Ä–≥–æ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
```

---

## üîß **–ì–æ—Ç–æ–≤—ã–µ –∫ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—é —Ä–µ—à–µ–Ω–∏—è (—Å–ª–µ–¥—É—é—â–∏–µ 24 —á–∞—Å–∞)**

### **1. –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ - –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å:**
```csharp
// –î–æ–±–∞–≤–∏—Ç—å –≤ —Å—Ü–µ–Ω—É –∫–∞–∫ –Ω–æ–≤—ã–π GameObject —Å —ç—Ç–∏–º —Å–∫—Ä–∏–ø—Ç–æ–º
[System.Serializable]
public class QuickDiagnostics : MonoBehaviour {
    [Header("Quick Performance Check")]
    public bool runOnStart = true;
    public int measurementFrames = 300; // 5 seconds at 60fps
    
    void Start() {
        if (runOnStart) {
            StartCoroutine(QuickPerformanceCheck());
        }
    }
    
    [ContextMenu("Run Quick Diagnostics")]
    public void RunDiagnostics() {
        StartCoroutine(QuickPerformanceCheck());
    }
    
    IEnumerator QuickPerformanceCheck() {
        Debug.Log("üîç Starting Quick Performance Diagnostics...");
        
        float totalFrameTime = 0f;
        float minFPS = float.MaxValue;
        float maxFPS = 0f;
        int frameCount = 0;
        
        long startMemory = Profiler.GetTotalAllocatedMemory(Profiler.Area.Managed);
        
        for (int i = 0; i < measurementFrames; i++) {
            float currentFPS = 1.0f / Time.deltaTime;
            totalFrameTime += Time.deltaTime;
            
            minFPS = Mathf.Min(minFPS, currentFPS);
            maxFPS = Mathf.Max(maxFPS, currentFPS);
            frameCount++;
            
            yield return null;
        }
        
        long endMemory = Profiler.GetTotalAllocatedMemory(Profiler.Area.Managed);
        long memoryDelta = endMemory - startMemory;
        
        // –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
        float averageFPS = frameCount / totalFrameTime;
        float memoryMB = memoryDelta / (1024f * 1024f);
        
        string report = $@"
üìä QUICK PERFORMANCE REPORT:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üì± FPS Statistics:
   ‚Ä¢ Average FPS: {averageFPS:F1}
   ‚Ä¢ Min FPS: {minFPS:F1}  
   ‚Ä¢ Max FPS: {maxFPS:F1}
   ‚Ä¢ Frame consistency: {((maxFPS - minFPS) < 10 ? "‚úÖ Good" : "‚ùå Unstable")}

üíæ Memory Analysis:
   ‚Ä¢ Memory allocated during test: {memoryMB:F2} MB
   ‚Ä¢ Memory/second: {(memoryMB / (totalFrameTime)):F2} MB/s
   ‚Ä¢ GC pressure: {(memoryMB > 10 ? "üö® HIGH" : memoryMB > 5 ? "‚ö†Ô∏è Medium" : "‚úÖ Low")}

üéØ Priority Actions:
   {(averageFPS < 15 ? "üö® CRITICAL: FPS too low - apply GPU backend fix immediately!" : "")}
   {(memoryMB > 10 ? "üö® CRITICAL: High memory allocation - fix GC issues!" : "")}
   {(minFPS < averageFPS * 0.7f ? "‚ö†Ô∏è WARNING: Frame time spikes detected!" : "")}

üîß Next Steps:
   1. {(averageFPS < 20 ? "Switch Barracuda to GPU backend" : "‚úÖ FPS acceptable")}
   2. {(memoryMB > 5 ? "Profile and fix memory allocations" : "‚úÖ Memory usage OK")}
   3. Run full PerformanceBenchmark for detailed analysis
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê";
        
        Debug.Log(report);
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç—á–µ—Ç –≤ —Ñ–∞–π–ª
        string filePath = Path.Combine(Application.persistentDataPath, "quick_diagnostics.txt");
        File.WriteAllText(filePath, report);
        Debug.Log($"üíæ Report saved to: {filePath}");
    }
}
```

### **2. –ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ‚Ññ1 - GPU Backend:**
```csharp
// –î–æ–±–∞–≤–∏—Ç—å –≤ SegmentationManager –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–π —Å–∫—Ä–∏–ø—Ç
public class CriticalPerformanceFix : MonoBehaviour {
    [ContextMenu("Apply Critical GPU Fix")]
    void ApplyGPUFix() {
        var segmentationManager = FindFirstObjectByType<SegmentationManager>();
        if (segmentationManager == null) {
            Debug.LogError("SegmentationManager not found!");
            return;
        }
        
        Debug.Log("üöÄ Applying critical GPU performance fix...");
        
        // –ß–µ—Ä–µ–∑ reflection –Ω–∞—Ö–æ–¥–∏–º worker –∏ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –µ–≥–æ —Å GPU backend
        var workerField = segmentationManager.GetType().GetField("worker", 
            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            
        if (workerField != null) {
            var currentWorker = workerField.GetValue(segmentationManager) as IWorker;
            currentWorker?.Dispose();
            
            // –ü–æ–ª—É—á–∞–µ–º –º–æ–¥–µ–ª—å –∏ —Å–æ–∑–¥–∞–µ–º GPU worker
            var modelField = segmentationManager.GetType().GetField("model", 
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            var model = modelField?.GetValue(segmentationManager) as Model;
            
            if (model != null) {
                var gpuWorker = model.CreateWorker(WorkerFactory.Type.ComputeShader);
                workerField.SetValue(segmentationManager, gpuWorker);
                Debug.Log("‚úÖ GPU backend applied successfully!");
            }
        }
    }
    
    [ContextMenu("Enable Extreme Optimization")]  
    void EnableExtremeOptimization() {
        var segmentationManager = FindFirstObjectByType<SegmentationManager>();
        if (segmentationManager != null) {
            segmentationManager.SetExtremeOptimizationMode(true);
            Debug.Log("üèÉ‚Äç‚ôÇÔ∏è Extreme optimization mode enabled!");
        }
    }
}
```

### **3. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏:**
```csharp
// –î–æ–±–∞–≤–∏—Ç—å –Ω–∞ –ª—é–±–æ–π GameObject –≤ —Å—Ü–µ–Ω–µ –¥–ª—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
public class InstantPerformanceMonitor : MonoBehaviour {
    [Header("Real-time Display")]
    public KeyCode toggleKey = KeyCode.F1;
    
    private bool showUI = true;
    private GUIStyle labelStyle;
    private PerformanceData currentData = new PerformanceData();
    
    struct PerformanceData {
        public float fps;
        public float frameTime;
        public float memoryMB;
        public float thermalState;
        public string status;
    }
    
    void Update() {
        if (Input.GetKeyDown(toggleKey)) {
            showUI = !showUI;
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∫–∞–∂–¥—ã–µ 10 –∫–∞–¥—Ä–æ–≤ –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
        if (Time.frameCount % 10 == 0) {
            UpdatePerformanceData();
        }
    }
    
    void UpdatePerformanceData() {
        currentData.fps = 1.0f / Time.deltaTime;
        currentData.frameTime = Time.deltaTime * 1000f;
        currentData.memoryMB = Profiler.GetTotalAllocatedMemory(Profiler.Area.Managed) / (1024f * 1024f);
        currentData.thermalState = SystemInfo.thermalState;
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        if (currentData.fps >= 25) currentData.status = "üü¢ EXCELLENT";
        else if (currentData.fps >= 20) currentData.status = "üü° GOOD";
        else if (currentData.fps >= 15) currentData.status = "üü† ACCEPTABLE";
        else currentData.status = "üî¥ POOR";
    }
    
    void OnGUI() {
        if (!showUI) return;
        
        if (labelStyle == null) {
            labelStyle = new GUIStyle(GUI.skin.label) {
                fontSize = 16,
                fontStyle = FontStyle.Bold
            };
        }
        
        string performanceText = $@"
üéØ PERFORMANCE MONITOR (F1 to toggle)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìä FPS: {currentData.fps:F1} | Status: {currentData.status}
‚è±Ô∏è Frame Time: {currentData.frameTime:F1}ms
üíæ Memory: {currentData.memoryMB:F1}MB
üå°Ô∏è Thermal: {(currentData.thermalState * 100):F0}%

üéÆ Controls:
F1 - Toggle this display
F2 - Run quick diagnostics  
F3 - Apply GPU fix
F4 - Enable extreme optimization
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê";

        GUI.Label(new Rect(10, 10, 400, 300), performanceText, labelStyle);
        
        // –ë—ã—Å—Ç—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π
        if (GUI.Button(new Rect(10, 320, 150, 30), "üöÄ Apply GPU Fix")) {
            FindFirstObjectByType<CriticalPerformanceFix>()?.ApplyGPUFix();
        }
        
        if (GUI.Button(new Rect(170, 320, 150, 30), "üèÉ Extreme Mode")) {
            FindFirstObjectByType<CriticalPerformanceFix>()?.EnableExtremeOptimization();
        }
    }
}
```

---

## üìà **–û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ —Ñ–∞–∑–∞–º**

| –§–∞–∑–∞ | –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞–º–∫–∏ | FPS | –í—Ä–µ–º—è –º–æ–¥–µ–ª–∏ | –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ—Ö–Ω–∏–∫–∏ |
|------|------------------|-----|--------------|------------------|
| **Baseline** | –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ | ~8-10 | 800ms+ | - |
| **–§–∞–∑–∞ 1** | 1-2 –Ω–µ–¥–µ–ª–∏ | 15+ | <400ms | GPU backend, async, GC fixes |
| **–§–∞–∑–∞ 2** | 3-6 –Ω–µ–¥–µ–ª—å | 20+ | <200ms | –ö–≤–∞–Ω—Ç–∏–∑–∞—Ü–∏—è, GPU preprocessing, Job System |
| **–§–∞–∑–∞ 3** | 2-3 –º–µ—Å—è—Ü–∞ | 25+ | <150ms | NNAPI/CoreML, thermal management, advanced ML |

### **–ö—Ä–∏—Ç–µ—Ä–∏–∏ —É—Å–ø–µ—Ö–∞:**
- ‚úÖ **–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –æ–ø—ã—Ç:** –ü–ª–∞–≤–Ω–æ–µ AR –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –±–µ–∑ –ª–∞–≥–æ–≤
- ‚úÖ **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** –°—Ç–∞–±–∏–ª—å–Ω—ã–µ 20+ FPS —Å –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∫–∞–¥—Ä–∞
- ‚úÖ **–≠–Ω–µ—Ä–≥–æ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:** –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã –Ω–∞ 30%+
- ‚úÖ **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å:** –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ thermal throttling –ø—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏

---

## üöÄ **–ù–µ–º–µ–¥–ª–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (—Å–ª–µ–¥—É—é—â–∏–µ 2 —á–∞—Å–∞)**

1. **–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å `QuickDiagnostics` —Å–∫—Ä–∏–ø—Ç** –≤ –ø—Ä–æ–µ–∫—Ç –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É
2. **–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π GPU fix** —á–µ—Ä–µ–∑ `CriticalPerformanceFix`
3. **–í–∫–ª—é—á–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥** —Å –ø–æ–º–æ—â—å—é `InstantPerformanceMonitor`
4. **–°–æ–∑–¥–∞—Ç—å baseline –æ—Ç—á–µ—Ç** –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è

**–ì–æ—Ç–æ–≤—ã–π –∫–æ–¥ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤:**
```csharp
// –°–æ–∑–¥–∞—Ç—å GameObject "PerformanceOptimizationSuite" –∏ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç —Å–∫—Ä–∏–ø—Ç
public class PerformanceOptimizationSuite : MonoBehaviour {
    [Header("Optimization Components")]
    public QuickDiagnostics diagnostics;
    public CriticalPerformanceFix criticalFix;
    public InstantPerformanceMonitor monitor;
    
    [ContextMenu("Initialize Full Suite")]
    void InitializeOptimizationSuite() {
        gameObject.AddComponent<QuickDiagnostics>();
        gameObject.AddComponent<CriticalPerformanceFix>();
        gameObject.AddComponent<InstantPerformanceMonitor>();
        
        Debug.Log("üéØ Performance Optimization Suite initialized!");
        Debug.Log("Press F1 for real-time monitor, F2 for diagnostics");
    }
    
    void Start() {
        Debug.Log("üöÄ remaluxAR Performance Optimization Suite ready!");
        Debug.Log("üîß Run 'Initialize Full Suite' from context menu to begin");
    }
}
```

–≠—Ç–æ—Ç –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –ø–ª–∞–Ω –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–µ—Ä–µ—Ö–æ–¥ –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–æ–±–ª–µ–º–∞–º–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∫ –≤—ã—Å–æ–∫–æ–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–º—É AR –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤—Å–µ—Ö —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ç–µ—Ö–Ω–∏–∫ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ Unity –∏ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è! üéØ‚ú® 